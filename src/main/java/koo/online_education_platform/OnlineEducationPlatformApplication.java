package koo.online_education_platform;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * [온라인 화상 채팅 플랫폼]
 *
 * WebSocket => 일반적인 HTTP (클라이언트와 서버가 데이터를 주고 받을 때 사용하는 프로토콜, 서버가 클라이언트의 요청에 응답하고 나면 연결은 끊김 - 비연결성) 와는 달리 Request-Response 구조가 아닌 커넥션 Open-Close 구조를 이용한다 (양방향 통신 가능, 실시간성 보장) 세명의 유저가 웹 소켓 서버에 입장한 상태에서 유저1이 웹소켓 서버에 메세지를 보내면 웹소켓 서버는 메세지를 유저2와 유저3에게 전달한다. 웹소켓 서버는 모든 통신을 추적하기 위해 메모리 파워가 중요한데, 유저가 많아질 수록 웹소켓 서버가 많이 필요하고 비용도 많이 들게 된다 (딜레이도 발생할 수 있으며, 웹 소켓 서버가 다운되면 유저들은 통신을 할 수 없다는 단점이 추가로 존재) (실시간 주식 가격 확인 플랫폼도 WebSocket을 사용)
 *
 * STOMP => 메세지 브로커를 활용하여 쉽게 메세지를 주고 받을 수 있는 프로토콜 => 웹 소켓 위에 얹어 함께 사용할 수 있는 하위(서브) 프로토콜 => Pub-Sub (발행-구독): 발신자가 메세지를 발행하면 수신자가 수신하는 메시징 페러다임, 메세지 브로커 (Topic): 발신자의 메세지를 받아와서 수신자들에게 메세지를 전달하는 주체 (프레임 단위의 프로토콜 => 매우 가벼움 & 주고 받는 메세지의 컨벤션을 따로 정의하지 않아도 된다) (외부 Messaging Queue를 사용할 수 있다 e,g, Kafka, RabbitMQ) (기존 WebSocket만을 사용한 통신은 발신자와 수신자를 Spring 단에서 직접 관리를 하고 메시지를 발신자로부터 수신자에게 전송하는 코드를 직접 구현해야함)
 *
 * 웹소켓을 지원하지 않는 브라우저 (크로스 브라우징 이슈 발생 시) => SockJs (클라이언트 단에서 지정된 주소를 지속으로 sub(구독) 하게 된다. 또한 지정한 주소로 pub(발송) 하는 역할도 한다) 혹은 Socket.io 라이브러리 사용
 *
 * Server-Sent Event => Http 통신을 종료안하고 계속 유지, 서버가 계속 능동적으로 클라이언트에게 데이터를 보낼 수 있음 but 클라이언트는 데이터 송신이 불가능하다는 단점 존재
 *
 * Http Streaming => WebSocket이 HTTP Streaming보다 가볍고, 통신 품질과 효율성이 훨씬 뛰어남, Http Streaming도 Server-Sent Event와 마찬가지로 서버 → 클라이언트 단방향 스트리밍이 기본, 클라이언트가 서버로 뭔가를 보내려면 따로 HTTP 요청을 새로 보내야함 & WebSocket은 연결을 수립할 때만 HTTP 핸드셰이크를 하고, 그 이후에는 매우 가벼운 프로토콜 (프레임 기반)로 통신함 즉, 헤더나 HTTP 포맷 없이 순수하게 필요한 데이터만 주고받는다.
 *
 * Polling => 클라이언트가 주기적으로 서버에 요청을 보내서 새로운 데이터가 있는지 확인하는 방식
 *
 * ================
 *
 * WebRTC => WebSocket의 단점을 보완하기 위해 등장한 WebRTC는 클라이언트들을 웹 소켓 서버에 연결하는 것이 아닌, 클라이언트 (브라우저) 끼리 연결하는 방식을 이용한다 (일종의 P2P, Peer to Peer 방식) (단순 텍스트 뿐만 아니라 영상, 오디오등 다양한 포맷의 데이터를 주고 받을 수 있다) (WebSocket 서버라는 중개자가 없기 때문에 더 빠르다) but WebRTC에서 내가 999명과 통신을 하게된다면 어떤 영상을 보낼 때 999명에게 보내야한다는 단점이 존재 한다. 그러나 WebSocket을 이용할 때 보다 쉽게 실시간 애플리케이션을 구축이 가능하다는 장점이 존재한다. 마지막으로는 WebRTC는 기본적으로 실시간성이 매우 중요하기 때문에 UDP 위에서 동작, 즉 데이터를 빠르게 전송할 수는 있지만, 이 과정에서 발생한 데이터 손실이 발생할 수도 있음 따라서 비디오라던가 오디오에 있어서 몇 프레임 정도가 끊기는 것은 큰 문제가 되지 않지만, 중요한 파일들을 전송할 때에는 이 데이터 손실이 문제를 일으킬 수도 있다.
 *
 * WebRTC를 지원하지 않는 브라우저 (크로스 브라우징 이슈 발생 시) => adapter.js 라이브러리 사용
 *
 * Signaling 서버 => WebRTC에서 두 사용자 간의 실시간 통신을 설정하기 위해 필요한 초기 연결 정보를 교환하는 역할을 하는 서버 (누구와 통신하는지 파악하는 것을 돕는 서버, 서로의 IP주소, PORT 주소등을 교환)
 *
 * WebRTC에서 시그널링을 WebSocket으로 하게 되면 연결 상태를 WebSocketSession을 통해 서버가 관리
 *
 * STUN 서버 => 자신의 Public IP를 알아낼 때 사용하는 서버 (Signaling 서버 동작 전에 자신의 공인 IP를 먼저 알아내야함)
 *
 * TURN 서버 => Firewall이 너무 강력해서 IP 주소를 못알아 내고 P2P 연결이 불가능 할 때 마지막 수단으로 사용 (TURN 서버가 중계자가 되어 A ↔ TURN ↔ B 구조로 미디어 데이터를 전달)
 *
 * 미디어 서버 (e.g. Kurento)는 P2P (1:1) 통신이 아닌 영상 통화나 음성 통화 같은 실시간 미디어 데이터를 중계, 처리, 분배하는 서버를 의미 간단히 말해, 여러 사람 간의 실시간 통신에서 데이터를 한 곳에 모아 처리하고 다시 나눠주는 중계소 역할을 수행 => 1:N, N:M 통신 가능
 *
 * SDP => WebRTC에서는 두 브라우저(혹은 클라이언트)가 영상, 오디오, 데이터 채널로 통신하려면 다음과 같은 정보를 서로 알아야 하고, 이 모든 정보를 담는 게 SDP이다.
 * 	- 내가 사용할 코덱 종류 (예: VP8, H264, Opus 등)
 * 	- 사용할 IP 주소와 포트
 * 	- 암호화 방식
 * 	- 오디오/비디오 여부
 * 	- 해상도/프레임레이트 제한 등
 *
 * ICE => Peer간의 네트워크 연결 설정을 위한 프레임워크 (네트워크 연결을 위한 다양한 경로(Candidate)를 찾고 연결을 확립)
 *
 * ===============
 *
 * [시나리오 예시]
 * 1. 화상 채팅 애플리케이션
 * 	- WebSocket/STOMP:
 * 	- 연결 요청
 * 	- 누구와 통화할지 (방 정보)
 * 	- SDP, ICE candidate 교환 (시그널링)
 * 	- 통화 시작/종료 알림
 *
 * WebRTC:
 * 	- 실제 오디오/비디오 스트림 전송
 * 	- 브라우저 간 직접 연결 (서버 부담 없음)
 *
 * SockJS:
 * 	- 주로 클라이언트 단에서 사용됨
 *
 * 왜 WebRTC만으로는 안 되는가?
 * WebRTC는 미디어를 전송할 줄은 알아도,어떻게 연결할지를 스스로 정하지 못함
 * => 이 과정을 "시그널링"이라고 부르고, 이를 위해 WebSocket 같은 통신 기술이 필요
 *
 * ==================
 *
 * ✅ WebRTC만으로 1대 다(N:1) 화상채팅은 기술적으로 가능은 합니다
 * 하지만 현실적인 성능과 확장성 문제 때문에 "미디어 서버"를 사용하는 것이 일반적입니다.
 * 🔍 WebRTC만으로 1대 다 화상채팅 구현하는 방법들
 * 1. Mesh Topology (브라우저 간 직접 연결)
 * 각 참여자가 다른 모든 참여자와 **직접 피어 연결(PeerConnection)**을 맺습니다.
 * 즉, N명이면 한 명당 (N-1)개의 연결을 만듭니다.
 * 예:
 * A → B, A → C, A → D (총 3개 연결)
 * B → A, B → C, B → D (총 3개 연결)
 * ...
 * ✅ 장점:
 * 서버 부하가 거의 없음 (P2P 구조)
 * 소규모 그룹 (2~4명)까지는 적절
 * ❌ 단점:
 * 연결 수가 **O(N²)**로 급증 → 브라우저/네트워크에 큰 부담
 * 고해상도 영상일수록 대역폭 소모가 폭발적으로 증가
 * 연결 관리 복잡도 증가
 *
 * 2. SFU (Selective Forwarding Unit, 선택적 전달 서버) ← 일반적 방식
 * 모든 사용자가 SFU 미디어 서버로만 연결하고,
 * SFU가 각 참가자의 미디어 스트림을 필요한 다른 사용자에게만 전달합니다.
 * 예: Jitsi Videobridge, mediasoup, Janus, Kurento 등
 * ✅ 장점:
 * 연결 수가 **O(N)**으로 단순화 (참여자는 서버 하나와만 연결)
 * 네트워크/브라우저 부담 감소
 * 확장성 우수 (수십~수백 명까지 가능)
 * 개별 해상도/대역폭 조절 가능
 * ❌ 단점:
 * 미디어 서버 구축/운영 필요 (비용, 유지관리)
 * SFU 위치에 따라 지연(latency) 영향 가능
 *
 * 3. MCU (Multipoint Control Unit, 중앙 혼합 서버)
 * 서버가 모든 비디오 스트림을 수신하여 **하나로 믹싱(합성)**하고 다시 전송
 * → Zoom 같은 회의 플랫폼에서 사용
 * ✅ 장점:
 * 사용자 1명이 서버로부터 1개의 스트림만 수신 → 저사양 환경 적합
 * 회의 녹화 등 부가 기능 구현 쉬움
 * ❌ 단점:
 * 서버 부하 매우 큼 (인코딩/디코딩 부담)
 * 영상 품질·유연성 낮음 (믹싱 구조라 개별 제어 어려움)
 *
 * 🔍 쉽게 이해하는 비유
 * 🎥 SFU = 멀티 캠 방송
 * 참가자 A, B, C가 각자 영상을 보내면, 서버는 받은 걸 그대로 각각에게 전송해요.
 * 참가자는 2명분의 영상(타인)을 직접 받아 디코딩하고 레이아웃도 직접 만듭니다.
 * 장점: 품질 좋고, 유연함
 * 단점: 참가자가 많아질수록 대역폭 부담 커짐
 *
 * 🎬 MCU = PD가 편집해서 방송
 * 참가자 A, B, C의 영상은 서버가 **합성 편집(예: 여러 명의 참가자 얼굴이 화면에 격자(grid) 형태로 동시에 나오는 화상 회의 화면 레이아웃 (갤러리 뷰))**하고,
 * 결과를 하나의 영상으로 만들어 모두에게 전송해요.
 * 장점: 참가자는 하나만 받으면 됨, 저사양 기기에도 좋음
 * 단점: 서버 부담 큼, 해상도/품질 제어 어려움
 *
 * ===============
 *
 * [문제점]
 * 1. 1:1 화상채팅만 가능한 상황, 1:N 혹은 N:M 화상채팅을 위해 미디어서버 도입 필요 (e.g. Kurento)
 * 2. 메세지 채팅방과 화상 채팅방 통합 필요
 * 3. 채팅 & 화상 채팅 기능에 DB가 전혀 사용되고 있지 않는 상황 (JPA 혹은 Spring Data JPA 도입 필요)
 * 4. 회원가입 기능 없음
 * 5. AWS S3, Naver API키 변경된 상태 => 파일 업로드, 소셜 로그인 불가
 */
@SpringBootApplication
public class OnlineEducationPlatformApplication {

	public static void main(String[] args) {
		SpringApplication.run(OnlineEducationPlatformApplication.class, args);
	}

}
